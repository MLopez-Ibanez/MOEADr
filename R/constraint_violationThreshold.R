#' "Violation Threshold" constraint handling method for MOEA/D
#'
#' Uses the Violation Threshold Constraint handling method to generate a
#' preference index.
#'
#' This function calculates the preference index of a set of neighborhoods
#' based on the "Violation Threshold" constraint handling method. Please
#' see {\code{help(order_neighborhood)}} for more information on the
#' preference index matrix.
#'
#' We define an individual as "Feasible", if its violation value V is below
#' a user defined Treshold. Also, we define the Violation Threshold "ev" as
#'
#' ev = 1/N * #feasible/N * sum(violations).
#'
#' Given two individuals a_i and a_j in the same
#' neighborhood, they are ordered according to the following rule:
#'
#' \itemize{
#' \item If both a_i and a_j are feasible OR if both v(a_i) and v(a_j) <= ev, they are ordered by smallest performance value
#' \item else they are ordered by smallest violation value
#' }
#'
#' @section Parameters:
#'
#' @param B Matrix of neighborhoods (generated by \code{define_neighborhood(...))})
#' @param bigZ Matrix of scalarized objective values for each neighborhood and the
#' incumbent solution (generated by \code{scalarize_values})
#' @param bigV Matrix of violation values for each neighborhood and the
#' incumbent solution
#' @param threshold A real-valued, non-negative feasibility treshold
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return [N x (T+1)] matrix of preference indexes. Each row contains
#' the T indexes of the candidate solutions in the neighborhood of
#' a given subproblem, plus a value of T+1 for the incumbent solution for
#' that subproblem, using the penalty-based constraint handling method.
#'
#' @export

constraint_violationThreshold <- function(B, bigZ, bigV, threshold, V, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ),dim(bigV)),
    is.numeric(threshold),
    threshold >= 0
    )
  # ==========

  # QUESTION: Vt (incumbent solutions) are included in bigV, bigZ. Should
  # We include the incumbent solutions in the calculation of ev?

  ev <- ((sum(V <= threshold)) / (length(V) ** 2)) * sum(V)
  feasible <- ((bigV <= threshold) | (bigV <= ev))

  # Create the matrix of performance for feasible indexes,
  # and of violation for infeasible indexes.
  bigF <- bigZ
  bigIF <- bigV
  bigF[!feasible] <- NA
  bigIF[feasible] <- NA

  # Sort the feasible and infeasible matrixes, putting
  # all NAs in the back or front, respectively
  indxF <- t(apply(bigF,
                   MARGIN = 2,
                   FUN = order,
                   na.last = TRUE))

  indxIF <- t(apply(bigIF,
                    MARGIN = 2,
                    FUN = order,
                    na.last = FALSE))

  # Merge feasible and unfeasible matrixes, using NAs as
  # a mask.
  indx.joint <- t(sapply(1:ncol(bigZ),
                         function(i) { (indxIF[i, ] * !is.na(bigIF[indxIF[i, ], i])) +
                                       (indxF[i,]*!is.na(bigF[indxF[i,],i])) }
                         ))

  return(indx.joint)
}

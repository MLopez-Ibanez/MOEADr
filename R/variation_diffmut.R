#' Differential Mutation
#'
#' Differential Mutation implementation for the MOEA/D
#'
#' This function generalizes many variations of the Differential Mutation
#' operator with general form:
#'
#' u <- x_basis + Phi(x_a - x_b)
#'
#' Where u is the new candidate vector, Phi is a real number != 0,
#' and x_basis, x_a and x_b are distinct vectors from the population.
#'
#' This function include the following variations of this operator:
#'
#' \itemize{
#'    \item Phi may be either constant (user provided) or randomly chosen.
#'    \item x_basis can be a random vector from the population
#'          (\code{basis = "rand"})
#'    \item x_basis can be the mean point in the T neighborhood points
#'          (\code{basis = "mean"})
#'    \item x_basis can be the weighted mean point in the T neighborhood points
#'          (\code{basis = "wgi"})
#' }
#'
#' @param X Population matrix
#' @param P Matrix of selection probabilities (generated by
#' \code{define_neighborhood(...)})
#' @param B Matrix of neighborhoods (generated by
#' \code{define_neighborhood(...)})
#' @param Phi Mutation parameter, random if NULL
#' @param basis how to select the basis vector, can be one of "random", "mean" or "wgi"
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return Matrix \code{X}' containing the mutated population
#'
#' @section References:
#' K. Price, R.M. Storn, J.A. Lampinen, "Differential Evolution: A
#' Practical Approach to Global Optimization", Springer 2005
#'
#' D. V. Arnold, “Weighted multirecombination evolution strategies,”
#' Theoretical Computer Science 361(1):18–37, 2006.
#'
#' @export

variation_diffmut <- function(X, P, B, Phi, basis = 'rand', ...){

  # ========== Error catching and default value definitions
  assertthat::assert_that(
    is.numeric(X) && is.matrix(X),
    is.numeric(P) && is.matrix(P) && is_within(P, 0, 1, strict = FALSE),
    identical(nrow(X), nrow(P)),
    nrow(P) == ncol(P),
    is.numeric(B) && is.matrix(B),
    nrow(B) == nrow(X),
    is.null(Phi) || (is.numeric(Phi) && Phi != 0),
    is.element(basis, c('rand', 'mean', 'wgi')))
  # ==========

  dimX <- dim(X)
  # Generate replacement indexes for xbasis, x0, x1
  # (Basis is recreated if 'mean' or 'wgi')
  R <- t(sapply(1:dimX[1],
                FUN = function(i) {
                  sample.int(dimX[1],
                             size    = 3,
                             replace = FALSE,
                             prob    = P[, i]) }))

  if (is.null(Phi)) {
    Phi <- matrix(stats::runif(dimX[1]),
                  nrow  = dimX[1],
                  ncol  = dimX[2],
                  byrow = FALSE)
  }

  if (basis == "rand"){
    Xb <- X[R[, 1], ]
  } else if (basis == "mean"){
    Xb <- t(sapply(1:nrow(X),
                   FUN = function(i) {
                     apply(X[B[i, ], ],
                           MARGIN = 2,
                           FUN    = mean) }))
  } else if (basis == "wgi"){
    # Capture moead() environment (variable "call.env" within the calling
    # environment "perform_variation()")
    moead.env <- parent.frame()$call.env

    # Check whether bigZ exists in the calling environment, and calculate it if
    # not (which will happen only once, at the first iteration)
    if("bigZ" %in% names(moead.env)) {
      bigZ <- moead.env$bigZ
    } else {
      normYs <- scale_objectives(moead.env)
      bigZ   <- scalarize_values(moead.env, normYs, B)
    }
    # Remove the last row, which refers to x_i^{(t-1)}
    bigZ <- t(bigZ[-nrow(bigZ), ])

    # Check whether wgi.W exists in the calling environment, and calculate it if
    # not (which will happen only once, at the first iteration)
    if(!("wgi.W" %in% names(moead.env))) {
      wgi.W <- log(ncol(bigZ) + 0.5) - log(1:ncol(bigZ))
      moead.env$wgi.W <- matrix(wgi.W / sum(wgi.W),
                                nrow = ncol(bigZ),
                                ncol = dimX[2],
                                byrow = FALSE)
    }
    wgi.W <- moead.env$wgi.W

    Xb <- t(sapply(1:dimX[1],
                   FUN = function(i){
                     indx <- order(bigZ[i, ])
                     colSums(wgi.W * X[B[i, indx], ])
                   }))
  }

  # Perform mutations and return
  return(Xb + Phi * (X[R[, 2], ] - X[R[, 3], ]))
}

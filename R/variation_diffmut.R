#' Differential Mutation
#'
#' Differential Mutation implementation for the MOEA/D
#'
#' This function generalizes many variations of the Differential Mutation
#' operator with general form:
#'
#' u <- x_basis + Phi(x_a - x_b)
#'
#' Where u is the new candidate vector, Phi is a real number != 0,
#' and x_basis, x_a and x_b are distinct vectors from the population.
#'
#' This function include the following variations of this operator:
#'
#' \itemize{
#'    \item Phi may be either constant (user provided) or randomly chosen.
#'    \item x_basis can be a random vector from the population
#'          (\code{basis = "rand"})
#'    \item x_basis can be the mean point in the T neighborhood points
#'          (\code{basis = "mean"})
#'    \item x_basis can be the weighted mean point in the T neighborhood points
#'          (\code{basis = "wgi"})
#' }
#'
#' @param X Population matrix
#' @param P Matrix of selection probabilities (generated by
#' \code{define_neighborhood(...)})
#' @param B Matrix of neighborhoods (generated by
#' \code{define_neighborhood(...)})
#' @param phi Mutation parameter, random if NULL
#' @param basis how to select the basis vector, can be one of "random", "mean" or "weighted"
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return Matrix \code{X}' containing the mutated population
#'
#' @section References:
#' K. Price, R.M. Storn, J.A. Lampinen, "Differential Evolution: A
#' Practical Approach to Global Optimization", Springer 2005
#'
#' D. V. Arnold, “Weighted multirecombination evolution strategies,”
#' Theoretical Computer Science 361(1):18–37, 2006.
#'
#' @export

variation_diffmut <- function(X = NULL,
                              P = NULL,
                              B = NULL,
                              phi = NULL,
                              basis = 'rand', ...){

  # ========== Error catching and default value definitions
  assertthat::assert_that(
    is.numeric(X) && is.matrix(X),
    is.numeric(P) && is.matrix(P) && is_within(P, 0, 1, strict = FALSE),
    identical(nrow(X), nrow(P)),
    nrow(P) == ncol(P),
    is.numeric(B) && is.matrix(B),
    nrow(B) == nrow(X),
    is.null(phi) || (is.numeric(phi) && phi != 0),
    is.element(basis, c('rand', 'mean', 'wgi')))
  # ==========

  dimX <- dim(X)
  # Generate replacement indexes for xbasis, x0, x1
  # (Basis is recreated if 'mean' or 'wgi')
  R <- t(sapply(1:dimX[1],
                FUN = function(i) {
                  sample.int(dimX[1],
                             size    = 3,
                             replace = FALSE,
                             prob    = P[, i]) }))

  if (is.null(phi)) {
    Phi <- matrix(stats::runif(dimX[1]),
                  nrow  = dimX[1],
                  ncol  = dimX[2],
                  byrow = FALSE)
  }

  if (basis == "rand"){
    Xb <- X[R[, 1], ]
  } else if (basis == "mean"){
    Xb <- t(sapply(1:nrow(X),
                   FUN = function(i) {
                     apply(X[B[i, ], ],
                           MARGIN = 2,
                           FUN    = mean) }))
  } else if (basis == "wgi"){
    # TODO -- weighted mean variation (wgi)
  }

  # Perform mutations and return
  return(Xb + Phi * (X[R[, 2], ] - X[R[, 3], ]))
}

#' None constraint handling method for MOEA/D
#'
#' Construct the preference index matrix based only on performance values.
#'
#' This function ignores the violation values when constructing the preference index
#' matrix, using only the scalarized performance values.
#'
#' @section Parameters:
#'
#' @param B Matrix of neighborhoods (generated by \code{define_neighborhood(...))})
#' @param bigZ Matrix of scalarized objective values for each neighborhood and the
#' incumbent solution (generated by \code{scalarize_values})
#' @param bigV Matrix of violation values for each neighborhood and the
#' incumbent solution
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return [N x (T+1)] matrix of preference indexes. Each row contains
#' the T indexes of the candidate solutions in the neighborhood of
#' a given subproblem, plus a value of T+1 for the incumbent solution for
#' that subproblem.
#'
#' @export

constraint_none <- function(B, bigZ, bigV, beta, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ),dim(bigV)),
    is.numeric(beta),
    beta > 0
    )
  # ==========

  # Get the selection matrix for all neighborhoods
  sel.indx <- t(apply(bigZ,
                      MARGIN = 2,
                      FUN = function (X) { unlist(as.matrix(sort.int(X, index.return = TRUE))[2]) }))
  # Code snipped for getting vector of sorting indexes from
  # https://joelgranados.com/2011/03/01/r-finding-the-ordering-index-vector/

  return(sel.indx)
}

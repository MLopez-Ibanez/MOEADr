#' Scalarize values for MOEA/D
#'
#' Perform scalarization for the MOEADr package.
#'
#' This routine calculates the scalarized performance values for the MOEA/D.
#'
#' @section Parameters:
#' This routine receives two input variables:
#' \itemize{
#'   \item \code{moead.env} is generated within the calling function
#'     \code{update_population()}. See \code{\link{update_population}} for more
#'     information.
#'   \item\code{normYs} is a list generated by function
#'   \code{scale_objectives(...)}, containing two matrices of scaled objective
#'   values (\code{Y} and \code{Yt}) and two vectors, containing the current
#'   estimates of the ideal (\code{minP}) and nadir (\code{maxP}) points. See
#'   \code{\link{scale_objectives}} for details.
#' }
#'
#' The environment listed in \code{moead.env} must contain a variable
#' \code{aggfun}, which provides the type of scalar aggregation function to be
#' employed. The list of available scalarization methods can be generated using
#'          \code{get_scalarization_methods()}
#'
#' @param moead.env list representing the environment of the base function
#' \code{moead}.
#' @param normYs list containing matrices of scaled objective values (see
#' section \code{Parameters}).
#' @param B neighborhood matrix, generate by \code{\link{define_neighborhood}}.
#'
#' @return [(T + 1) x N] matrix of scalarized performance values. Each column
#' contains the T scalarized performances of the candidate solutions in the
#' neighborhood of a given subproblem, plus the scalarized performance value
#' for the incumbent solution for that subproblem.
#'
#' @export

scalarize_values <- function(moead.env, normYs, B){

  # ========== Error catching and default value definitions
  # Input "moead.env" is assumed to have been already verified in
  # update_population(), and will not be re-checked here.
  # Input normYs is assumed to have been generated by scale_objectives(), and
  # will not be re-checked here.
  # ==========

  # Get matrix of objective values for each neighborhood, ordered by
  # subproblem. It's a (nrow(X) * T) x m matrix
  bigY <- normYs$Y[as.vector(t(B)), ]

  # Get matrix of weight vectors for each subproblem, replicated for the
  # neighborhoods. It's a (nrow(X) * T) x m matrix
  bigW <- moead.env$W[rep(1:nrow(moead.env$W),
                          each  = ncol(B)), ]

  # Prepare bigZ matrix
  bigZ <- matrix(numeric(),
                 ncol = nrow(moead.env$Y),
                 nrow = ncol(B) + 1)

  # Scalarization function to be used
  function_name <- paste0("scalarization_", tolower(moead.env$aggfun$name))

  # Fill in the scalarized function values for the candidate solutions
  bigZ[1:ncol(B), ] <- matrix(do.call(function_name,
                                      args = list(Y    = bigY,
                                                  W    = bigW,
                                                  aggfun = moead.env$aggfun,
                                                  minP = normYs$minP,
                                                  maxP = normYs$maxP)),
                                      ncol  = nrow(moead.env$W),
                                      byrow = FALSE)

  # Fill in the scalarized function values for the incumbent solutions
  bigZ[nrow(bigZ), ] <- do.call(function_name,
                                args = list(Y    = normYs$Yt,
                                            W    = moead.env$W,
                                            aggfun = moead.env$aggfun,
                                            minP = normYs$minP,
                                            maxP = normYs$maxP))

  # Return matrix bigZ
  return(bigZ)
}

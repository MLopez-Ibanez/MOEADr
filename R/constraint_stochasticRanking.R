#' "Stochastic Ranking" constraint handling method for MOEA/D
#'
#' Uses the Stochastic Ranking Constraint handling method to generate a
#' preference index.
#'
#' This function calculates the preference index of a set of neighborhoods
#' based on the "Stochastic Ranking" constraint handling method. Please
#' see {\code{help(order_neighborhood)}} for more information on the
#' preference index matrix.
#'
#' We define an individual as "Feasible", if its violation value V is below
#' a user defined Threshold. Given two individuals a_i and a_j in the same
#' neighborhood, they are ordered according to the following rule:
#'
#' \itemize{
#' \item If both a_i and a_j are feasible OR if U(0,1) <= pf, they are ordered by smallest performance value
#' \item If either a_i or a_j ar unfeasible AND if U(0,1) > pf, they are ordered by smallest violation value
#' }
#'
#' @section Parameters:
#'
#' @param B Matrix of neighborhoods (generated by \code{define_neighborhood(...))})
#' @param bigZ Matrix of scalarized objective values for each neighborhood and the
#' incumbent solution (generated by \code{scalarize_values})
#' @param bigV Matrix of violation values for each neighborhood and the
#' incumbent solution
#' @param threshold A real-valued, non-negative feasibility treshold
#' @param pf A probability value to consider non-feasible solutions as feasible
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return [N x (T+1)] matrix of preference indexes. Each row contains
#' the T indexes of the candidate solutions in the neighborhood of
#' a given subproblem, plus a value of T+1 for the incumbent solution for
#' that subproblem, using the penalty-based constraint handling method.
#'
#' @export

constraint_violationThreshold <- function(B, bigZ, bigV, threshold, pf, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ),dim(bigV)),
    is.numeric(threshold),
    threshold >= 0,
    is.numeric(pf),
    is_within(pf,0,1)
    )
  # ==========

  pf.matrix <- matrix(runif(prod(dim(bigZ))),dim(bigZ))
  feasible <- ((bigV <= threshold) | (pf.matrix <= pf))

  # Create the matrix of performance for feasible indexes,
  # and of violation for infeasible indexes.
  bigF <- bigZ
  bigIF <- bigV
  bigF[!feasible] <- NA
  bigIF[feasible] <- NA

  # Sort the feasible and infeasible matrixes, putting
  # all NAs in the back or front, respectively
  indxF <- t(apply(bigF,
                   MARGIN = 2,
                   FUN = order,
                   na.last = TRUE))

  indxIF <- t(apply(bigIF,
                    MARGIN = 2,
                    FUN = order,
                    na.last = FALSE))

  # Merge feasible and unfeasible matrixes, using NAs as
  # a mask.
  indx.joint <- t(sapply(1:ncol(bigZ),
                         function(i) { (indxIF[i, ] * !is.na(bigIF[indxIF[i, ], i])) +
                                       (indxF[i,]*!is.na(bigF[indxF[i,],i])) }
                         ))

  return(indx.joint)
}

#' "Penalty" constraint handling method for MOEA/D
#'
#' Uses the Penalty Constraint handling method to generate a
#' preference index.
#'
#' This function calculates the preference index of a set of neighborhoods
#' based on the "Penalty" constraint handling method. Please
#' see {\code{help(order_neighborhood)}} for more information on the
#' preference index matrix.
#'
#' The scalarized performance value of an individual is modified as follows
#'
#' performance_penalty = performance + beta*violation
#'
#' This performance value is then used to compare individuals within a neighborhood.
#'
#' @section Parameters:
#'
#' @param B Matrix of neighborhoods (generated by \code{define_neighborhood(...))})
#' @param bigZ Matrix of scalarized objective values for each neighborhood and the
#' incumbent solution (generated by \code{scalarize_values})
#' @param bigV Matrix of violation values for each neighborhood and the
#' incumbent solution
#' @param beta A real-valued, positive penalization constraint
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return [N x (T+1)] matrix of preference indexes. Each row contains
#' the T indexes of the candidate solutions in the neighborhood of
#' a given subproblem, plus a value of T+1 for the incumbent solution for
#' that subproblem, using the penalty-based constraint handling method.
#'
#' @export

constraint_penalty <- function(B, bigZ, bigV, beta, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    identical(dim(bigZ),dim(bigV)),
    is.numeric(beta),
    beta > 0
    )
  # ==========

  bigZV <- bigZ + beta*bigV

  # Get the selection matrix for all neighborhoods
  sel.indx <- t(apply(bigZV,
                      MARGIN = 2,
                      FUN = function (X) { unlist(as.matrix(sort.int(X, index.return = TRUE))[2]) }))
  # Code snipped for getting vector of sorting indexes from
  # https://joelgranados.com/2011/03/01/r-finding-the-ordering-index-vector/

  return(sel.indx)
}

#' "Penalty" constraint handling method for MOEA/D
#'
#' Compare and order a set of individuals using the "Penalty"
#' constraint handling method for the MOEADr package.
#'
#' This function receives a set of individuals, their scalarized fitness values
#' their violation value, and a neighborhood matrix. It calculates, for
#' each neighborhood, a "selection index" matrix which orders all individuals
#' in the neighborhood according to the following formula:
#'
#' fitness_penalty = fitness + beta*violation
#'
#'
#' @section Parameters:
#'
#' @param B Matrix of neighborhoods (generated by \code{define_neighborhood(...))})
#' @param bigZ Matrix of scalarized objective values for each neighborhood and the incumbent solution (generated by \code{scalarize_values})
#' @param V Vector of violation values for the current candidates
#' @param Vt Vector of violation values for the incumbent candidates
#' @param beta A real-valued, positive penalization constraint
#' @param ... other parameters (unused, included for compatibility with
#' generic call)
#'
#' @return A matrix with the same dimensions as bigZ. In the i-th row we have the indexes of bigZ in order of quality, taking
#' into account both the fitness value and the violation penalty.
#'
#' @export

constraint_penalty <- function(B, bigZ, bigV, beta, ...)
{
  # ========== Error catching and default value definitions
  assertthat::assert_that(
    is.numeric(X) && is.matrix(X)
    )
  # ==========

  # calculate the penalty matrix of the neighborhoods and incumbent
  bigV <- cbind(matrix(V[B],dim(B)),Vt)



  # Get the selection matrix for all neighborhoods
  sel.indx <- t(apply(moead.env$bigZ,
                      MARGIN = 2,
                      FUN = function (X) { unlist(as.matrix(sort.int(X, index.return = TRUE))[2]) }))
  # Code snipped for getting vector of sorting indexes from
  # https://joelgranados.com/2011/03/01/r-finding-the-ordering-index-vector/


}
